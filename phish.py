# -*- coding: utf-8 -*-
"""Phish.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uHBAgOxpAlGRHthJhXzXU_29OaUGGmOt
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
import xgboost as xgb

#df=pd.read_csv('Phishing_Legitimate_full.csv')
#df.head()

#df.isnull().sum()

#df.dtypes

"""
dropcols=['ExtFavicon','HostnameLength','ImagesOnlyInForm']
df=df.drop(dropcols, axis=1)
"""

#df

#cols=df.columns

#Y=df[['CLASS_LABEL']]
#Y

#X=df.drop('CLASS_LABEL',axis=1)
#X

#cols=cols[0:-1]
#for i in range(len(cols)):
 # col=cols[i]
  #plt.scatter(x=[i for i in range(10000)],y=X[[col]],c=Y.values,cmap='plasma')
  #plt.title(col)
  #plt.show()

#X=X.drop('id',axis=1)

#from sklearn.model_selection import train_test_split
#X_train,X_test,y_train,y_test=train_test_split(X,Y,test_size=0.2)

#from sklearn.ensemble import RandomForestClassifier
#rfc=RandomForestClassifier(n_estimators=200)
#rfc.fit(X_train,y_train)

#rfc.predict(X_test)

#rfc.score(X_test,y_test)

#importances=rfc.feature_importances_
#importances

#fimp=pd.Series(importances,index=X.columns)
#fimp.plot.bar()

#fimp

#fimp.sort_values()

#data=X[['PctExtHyperlinks','PctExtNullSelfRedirectHyperlinksRT','PctExtResourceUrls','FrequentDomainNameMismatch','PctNullSelfRedirectHyperlinks']]
#data

#X_train,X_test,y_train,y_test=train_test_split(data,Y,test_size=0.2)

#X_train

#y_train

#rfc5=RandomForestClassifier(n_estimators=500)
#rfc5.fit(X_train,y_train)

#rfc5.predict(X_test)

#rfc5.score(X_test,y_test)

#from sklearn.tree import DecisionTreeClassifier
#dctgini=DecisionTreeClassifier(criterion="gini")
#ctgini.fit(X_train,y_train)

#dctgini.predict(X_test)

#dctgini.score(X_test,y_test)

#dctent=DecisionTreeClassifier(criterion="entropy")
#dctent.fit(X_train,y_train)

#dctent.predict(X_test)

#dctent.score(X_test,y_test)

#from sklearn.svm import SVC
#svm5=SVC(kernel='rbf')
#svm5.fit(X_train,y_train

#svm5.predict(X_test)

#svm5.score(X_test,y_test)

"""
data2=X[['PctExtHyperlinks','PctExtNullSelfRedirectHyperlinksRT','PctExtResourceUrls','FrequentDomainNameMismatch','PctNullSelfRedirectHyperlinks','NumDash','ExtMetaScriptLinkRT','InsecureForms','NumNumericChars','PathLevel']]
data2
"""

#X_train,X_test,y_train,y_test=train_test_split(data2,Y,test_size=0.2)
#X_train

#y_train

"""
rfc10=RandomForestClassifier(n_estimators=500)
rfc10.fit(X_train,y_train)
"""

#rfc10.predict(X_test)

#rfc10.score(X_test,y_test)

#dctgini.fit(X_train,y_train)
#dctgini.predict(X_test)
#dctgini.score(X_test,y_test)

#dctent.fit(X_train,y_train)
#dctent.predict(X_test)
#dctent.score(X_test,y_test)

#svm5.fit(X_train,y_train)
#svm5.predict(X_test)
#svm5.score(X_test,y_test)

#X_train,X_test,y_train,y_test=train_test_split(X,Y,test_size=0.2)

#dctgini.fit(X_train,y_train)
#dctgini.predict(X_test)
#dctgini.score(X_test,y_test)

#dctent.fit(X_train,y_train)
#dctent.predict(X_test)
#dctent.score(X_test,y_test)

#svm5.fit(X_train,y_train)
#svm5.predict(X_test)
#svm5.score(X_test,y_test)

#import xgboost as xgb
#model=xgb.XGBClassifier(use_label_encoder=False,eval_metric='mlogloss',n_estimators=100)
#model.fit(X_train,y_train)

#model.predict(X_test)

#model.score(X_test,y_test)

"""***This Marks the Start of Blockchain Phishing Detection***






"""

df=pd.read_csv("transaction_dataset.csv")
df.head()

df.isnull().sum()

df.columns

dropcols=[' ERC20 most sent token type',' ERC20_most_rec_token_type','Address']
df_phase1=df.drop(dropcols,axis=1)
df_phase1

"""
colsnull=[' Total ERC20 tnxs',' ERC20 total Ether received',' ERC20 total ether sent',' ERC20 total Ether sent contract',' ERC20 uniq sent addr',' ERC20 uniq rec addr',' ERC20 uniq sent addr.1',' ERC20 uniq rec contract addr',' ERC20 avg time between sent tnx',' ERC20 avg time between rec tnx',' ERC20 avg time between rec 2 tnx',' ERC20 avg time between contract tnx',' ERC20 min val rec',' ERC20 max val rec',' ERC20 avg val rec',' ERC20 min val sent',' ERC20 max val sent',' ERC20 avg val sent',' ERC20 min val sent contract',' ERC20 max val sent contract',' ERC20 avg val sent contract',' ERC20 uniq sent token name',' ERC20 uniq rec token name']
df_phase2=df_phase1
for i in colsnull:
  df_phase2[i].fillna(df_phase2[i].mean(),inplace=True)
df_phase2
"""

df_phase2=df_phase1.dropna(axis=0)

df_phase2

df_phase2.isnull().sum()

df_phase3=df_phase2
X=df_phase2.drop('FLAG',axis=1)

Y=df_phase3['FLAG']

Y=pd.DataFrame(Y,columns=['FLAG'])

Y

Y['FLAG'].value_counts()

cols=X.columns

plt.scatter(x=[i for i in range(9012)],y=Y['FLAG'],c=Y.values,cmap='plasma')
plt.xlabel('Index')
plt.ylabel("output")

cols=cols[0:-1]
for i in range(len(cols)):
  col=cols[i]
  plt.scatter(x=[i for i in range(9012)],y=X[[col]],c=Y.values,cmap='plasma')
  plt.title(col)
  plt.show()

droppers=['min value sent to contract','max val sent to contract','avg value sent to contract','total ether sent contracts',' ERC20 total Ether received',' ERC20 total ether sent',' ERC20 total Ether sent contract',' ERC20 avg time between sent tnx',' ERC20 avg time between rec tnx',' ERC20 avg time between rec 2 tnx',' ERC20 avg time between contract tnx',' ERC20 min val sent',' ERC20 max val sent',' ERC20 avg val sent',' ERC20 min val sent contract',' ERC20 max val sent contract',' ERC20 avg val sent contract']

df_phase3=df_phase2.drop(droppers,axis=1)
df_phase3
useless=['Index']
df_phase3=df_phase3.drop(useless,axis=1)

noofcols=df_phase3.columns
len(noofcols)

len(df.columns)

X=df_phase3.drop('FLAG',axis=1)
X

Y=df_phase3[['FLAG']]
Y

X_train,X_test,Y_train,Y_test=train_test_split(X,Y,test_size=0.2)
X_train

Y_train

from sklearn.tree import export_graphviz
from six import StringIO
from IPython.display import Image
import pydotplus

rfc=RandomForestClassifier(n_estimators=200)
rfc.fit(X_train,Y_train)

rfcans=rfc.predict(X_test)

rfc.score(X_test,Y_test)

estimator = rfc.estimators_[5]
export_graphviz(estimator, out_file='tree.dot', 
                class_names = ['0','1'], proportion = False, 
                precision = 2, filled = True)
from subprocess import call
call(['dot', '-Tpng', 'tree.dot', '-o', 'tree.png', '-Gdpi=600'])
Image(filename = 'tree.png')

xgc=xgb.XGBClassifier(use_label_encoder=False,eval_metric='mlogloss',n_estimators=100)
xgc.fit(X_train,Y_train)

xgcans=xgc.predict(X_test)

xgc.score(X_test,Y_test)

from sklearn.tree import DecisionTreeClassifier
dctgini=DecisionTreeClassifier(criterion='gini')
dctgini.fit(X_train,Y_train)

dctgini.predict(X_test)

dctgini.score(X_test,Y_test)

dot_data = StringIO()
export_graphviz(dctgini, out_file=dot_data,  
                filled=True, special_characters=True,class_names=['0','1'])
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
graph.write_png('blockc.png')
Image(graph.create_png())

dctent=DecisionTreeClassifier(criterion='entropy')
dctent.fit(X_train,Y_train)

dctent.score(X_test,Y_test)

dot_data = StringIO()
export_graphviz(dctent, out_file=dot_data,  
                filled=True, special_characters=True,class_names=['0','1'])
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
graph.write_png('blocks.png')
Image(graph.create_png())

from sklearn import metrics

confusion_matrix = metrics.confusion_matrix(Y_test, rfcans)

cm_display = metrics.ConfusionMatrixDisplay(confusion_matrix = confusion_matrix, display_labels = [False, True])
cm_display.plot()
plt.show()

confusion_matrix = metrics.confusion_matrix(Y_test, xgcans)

cm_display = metrics.ConfusionMatrixDisplay(confusion_matrix = confusion_matrix, display_labels = [False, True])
cm_display.plot()
plt.show()

import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers.core import Activation
from keras.utils.generic_utils import get_custom_objects

classifier=Sequential()
classifier.add(Dense(activation='sigmoid',units=11,input_dim=28))
classifier.add(Dense(activation='sigmoid',units=5))
classifier.add(Dense(units=1,activation='sigmoid'))

classifier.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])

classifier.fit(X_train, Y_train, batch_size=10, epochs=100)

y_pred=classifier.predict(X_test)
for i in range(len(y_pred)):
  if(y_pred[i]<0.5):
    y_pred[i]=0
  else:
    y_pred[i]=1
  print(y_pred[i])

from sklearn.metrics import confusion_matrix, accuracy_score
cm = confusion_matrix(Y_test, y_pred)
print(cm)
accuracy_score(Y_test,y_pred)

!pip3 install ann_visualizer

!pip3 install graphviz

from ann_visualizer.visualize import ann_viz;


ann_viz(classifier, view=True, filename="ann.gv", title="ANN Representation of Phishing Classification")

from graphviz import Source
Source.from_file('ann.gv')